name: Build

on:
  push:
    paths:
      # Source code and assets, build and test scripts
      - packages/**
      - appimage/**
      - common/**
      - scripts/build_*
      - scripts/test-packs/**
      # Rust toolchain configuration file
      - rust-toolchain
      - rustfmt.toml
      - deny.toml
      - Cargo.toml
      - Cargo.lock
      - '**/.cargo/config.toml'
      # Git files that may affect how test files are checked in
      - .gitattributes
      # GitHub Actions workflows
      - .github/workflows/*.yml
      # Docker image
      - Dockerfile
  pull_request:
    types:
      - opened
      - synchronize
  release:
    types:
      - published

env:
  CARGO_TERM_COLOR: always
  CARGO_DEB_VERSION: 1.34.0
  APPIMAGE_BUILDER_VERSION: 1.0.0a3
  CONST_RANDOM_SEED: ${{ secrets.CONST_RANDOM_SEED }}
  APPDIR: AppDir
  REPO_DIR: /pkgs

jobs:
  static-analysis:

    runs-on: ubuntu-latest

    # Only run if this is not a pull request, or for pull requests on forks
    if: github.event_name != 'pull_request' ||
      github.event.pull_request.head.repo.full_name != 'ComunidadAylas/PackSquash'

    steps:
      - name: Checkout source
        uses: actions/checkout@v3

      - name: Install Rust toolchain
        uses: actions-rs/toolchain@v1
        with:
          profile: minimal
          components: rustfmt, clippy

      - name: Install development packages
        run: |
          sudo apt-get update
          sudo apt-get install desktop-file-utils

      - name: Check workflow write permission
        id: check_write_permission
        uses: scherermichael-oss/action-has-permission@1.0.6
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

      - name: Clippy check (with annotations)
        uses: actions-rs/clippy-check@v1
        if: steps.check_write_permission.outputs.has-permission
        with:
          args: --all-targets -- -D warnings
          token: ${{ secrets.GITHUB_TOKEN }}

      - name: Clippy check (without annotations)
        if: ${{ !steps.check_write_permission.outputs.has-permission }}
        run: cargo clippy --all-targets -- -D warnings

      - name: Cargo deny check
        uses: EmbarkStudios/cargo-deny-action@v1

      - name: Check PackSquash Linux desktop entries correctness
        run: desktop-file-validate common/assets/*.desktop

      - name: Format Rust source code
        run: cargo fmt

      - name: Commit and push Rust source code format changes
        uses: EndBug/add-and-commit@v9
        with:
          message: 'Format Rust source code using rustfmt'
          author_name: github-actions[bot]
          author_email: 41898282+github-actions[bot]@users.noreply.github.com

  linux-x64-gnu:

    runs-on: ubuntu-latest

    container: debian:bullseye-slim

    env:
      CARGO_BUILD_TARGET: x86_64-unknown-linux-gnu
      DEBIAN_FRONTEND: noninteractive

    # Only run if this is not a pull request, or for pull requests on forks
    if: github.event_name != 'pull_request' ||
      github.event.pull_request.head.repo.full_name != 'ComunidadAylas/PackSquash'

    steps:
      - name: Install development packages
        run: |
          apt-get update
          # curl is required by rustup.
          # markdown and html2text are required to generate the Debian package only.
          # The last line contains packages necessary for appimage-builder only
          apt-get install -yq build-essential git curl \
                              markdown html2text \
                              python3-pip patchelf file zsync desktop-file-utils fakeroot gtk-update-icon-cache

      - name: Checkout source
        uses: actions/checkout@v3
        with:
          fetch-depth: 0

      - name: Install Rust toolchain
        uses: actions-rs/toolchain@v1
        with:
          profile: minimal
          components: rust-src

      - name: Cache Rust artifacts
        uses: Swatinem/rust-cache@v1

      - name: Install cargo-deb
        uses: actions-rs/install@v0.1
        with:
          crate: cargo-deb
          version: ${{ env.CARGO_DEB_VERSION }}

      - name: Install appimage-builder
        run: |
          pip install appimage-builder==${{ env.APPIMAGE_BUILDER_VERSION }}
          curl -L https://github.com/AppImage/AppImageKit/releases/download/continuous/appimagetool-x86_64.AppImage -o /opt/appimagetool
          chmod ugo+x /opt/appimagetool
          # Workaround from https://github.com/AppImageCrafters/appimage-builder/blob/v1.0.0-alpha.3/Dockerfile#L11-L15
          # to extract the appimagetool AppImage within a container
          cd /opt
          sed -i 's|AI\x02|\x00\x00\x00|' appimagetool
          /opt/appimagetool --appimage-extract > /dev/null
          mv /opt/squashfs-root /opt/appimagetool.AppDir
          ln -s /opt/appimagetool.AppDir/AppRun /usr/local/bin/appimagetool

      # Our build container minimal and it doesn't contain any systemd package.
      # systemd is responsible for setting up the machine ID files we use for
      # testing the system ID retrieval code, so copy a dummy one
      - name: Set up a dummy D-Bus machine ID for tests
        run: cat /proc/sys/kernel/random/boot_id | tr -d '-' > /run/machine-id

      - name: Run tests
        uses: actions-rs/cargo@v1
        with:
          command: test
          args: --release -- -Z unstable-options --report-time

      - name: Build with optimized standard library
        uses: actions-rs/cargo@v1
        with:
          command: build
          args: --target ${{ env.CARGO_BUILD_TARGET }} -Z build-std --release

      - name: Generate CLI Debian package
        run: scripts/build_deb.sh --target ${{ env.CARGO_BUILD_TARGET }} -p packsquash_cli -- -Z build-std

      - name: Generate CLI AppImage
        env:
          TARGET_APPIMAGE_ARCH: x86_64
          TARGET_APPIMAGE_APT_ARCH: amd64
        run: VERSION="$(git describe --tags --dirty=-custom)"
          appimage-builder --recipe appimage/recipe.yml --skip-test

      - name: Upload CLI binary
        uses: actions/upload-artifact@v3
        with:
          name: 'PackSquash executable (Linux, x64, glibc)'
          path: target/${{ env.CARGO_BUILD_TARGET }}/release/packsquash

      - name: Upload CLI Debian package
        uses: actions/upload-artifact@v3
        with:
          name: 'PackSquash CLI Debian package (amd64)'
          path: target/${{ env.CARGO_BUILD_TARGET }}/debian/packsquash_*.deb

      - name: Upload CLI AppImage
        uses: actions/upload-artifact@v3
        with:
          name: 'PackSquash CLI AppImage (x64)'
          path: PackSquash-*-x86_64.AppImage

      - name: Upload CLI AppImage update diff
        uses: actions/upload-artifact@v3
        with:
          name: 'PackSquash CLI AppImage zsync (x64)'
          path: PackSquash-*-x86_64.AppImage.zsync

  windows-x64-gnu:

    runs-on: windows-latest

    env:
      CARGO_BUILD_TARGET: x86_64-pc-windows-gnu

    # Only run if this is not a pull request, or for pull requests on forks
    if: github.event_name != 'pull_request' ||
      github.event.pull_request.head.repo.full_name != 'ComunidadAylas/PackSquash'

    steps:
      - name: Checkout source
        uses: actions/checkout@v3
        with:
          fetch-depth: 0

      - name: Install Rust toolchain
        uses: actions-rs/toolchain@v1
        with:
          target: ${{ env.CARGO_BUILD_TARGET }}
          profile: minimal
          components: rust-src

      - name: Cache Rust artifacts
        uses: Swatinem/rust-cache@v1

      - name: Run tests
        uses: actions-rs/cargo@v1
        with:
          command: test
          args: --release -- -Z unstable-options --report-time

      - name: Build with optimized standard library
        uses: actions-rs/cargo@v1
        with:
          command: build
          args: --target ${{ env.CARGO_BUILD_TARGET }} -Z build-std --release

      - name: Upload binary
        uses: actions/upload-artifact@v3
        with:
          name: 'PackSquash CLI executable (Windows, x64)'
          path: target/${{ env.CARGO_BUILD_TARGET }}/release/packsquash.exe

  macos-x64-darwin:

    runs-on: macos-11

    env:
      CARGO_BUILD_TARGET: x86_64-apple-darwin

    # Only run if this is not a pull request, or for pull requests on forks
    if: github.event_name != 'pull_request' ||
      github.event.pull_request.head.repo.full_name != 'ComunidadAylas/PackSquash'

    steps:
      - name: Checkout source
        uses: actions/checkout@v3
        with:
          fetch-depth: 0

      - name: Install Rust toolchain
        uses: actions-rs/toolchain@v1
        with:
          profile: minimal
          components: rust-src

      - name: Cache Rust artifacts
        uses: Swatinem/rust-cache@v1

      - name: Run tests
        uses: actions-rs/cargo@v1
        with:
          command: test
          args: --release -- -Z unstable-options --report-time

      - name: Build with optimized standard library
        uses: actions-rs/cargo@v1
        with:
          command: build
          args: --target ${{ env.CARGO_BUILD_TARGET }} -Z build-std --release

      - name: Upload CLI binary
        uses: actions/upload-artifact@v3
        with:
          name: 'PackSquash CLI executable (macOS, x64)'
          path: target/${{ env.CARGO_BUILD_TARGET }}/release/packsquash

  linux-aarch64-gnu:

    runs-on: ubuntu-latest

    container: debian:bullseye-slim

    env:
      CARGO_BUILD_TARGET: aarch64-unknown-linux-gnu
      DEBIAN_FRONTEND: noninteractive

    # Only run if this is not a pull request, or for pull requests on forks
    if: github.event_name != 'pull_request' ||
      github.event.pull_request.head.repo.full_name != 'ComunidadAylas/PackSquash'

    steps:
      - name: Install development packages and cross-compilation GCC toolchain
        run: |
          dpkg --add-architecture arm64
          apt-get update
          # liblzma-dev is required by cargo-deb. curl is required by rustup.
          # markdown and html2text are required to generate the Debian package only.
          # The last line contains packages necessary for appimage-builder only
          apt-get install -yq build-essential git liblzma-dev curl \
                              gcc-aarch64-linux-gnu qemu-user libc6:arm64 \
                              markdown html2text \
                              python3-pip patchelf file zsync desktop-file-utils fakeroot gtk-update-icon-cache

      - name: Checkout source
        uses: actions/checkout@v3
        with:
          fetch-depth: 0

      - name: Install Rust toolchain
        uses: actions-rs/toolchain@v1
        with:
          target: ${{ env.CARGO_BUILD_TARGET }}
          profile: minimal
          components: rust-src

      - name: Cache Rust artifacts
        uses: Swatinem/rust-cache@v1

      - name: Install cargo-deb
        uses: actions-rs/install@v0.1
        env:
          CARGO_BUILD_TARGET: x86_64-unknown-linux-gnu
        with:
          crate: cargo-deb
          version: ${{ env.CARGO_DEB_VERSION }}

      - name: Install appimage-builder
        run: |
          pip install appimage-builder==${{ env.APPIMAGE_BUILDER_VERSION }}
          curl -L https://github.com/AppImage/AppImageKit/releases/download/continuous/appimagetool-x86_64.AppImage -o /opt/appimagetool
          chmod ugo+x /opt/appimagetool
          # Workaround from https://github.com/AppImageCrafters/appimage-builder/blob/v1.0.0-alpha.3/Dockerfile#L11-L15
          # to extract the appimagetool AppImage within a container
          cd /opt
          sed -i 's|AI\x02|\x00\x00\x00|' appimagetool
          /opt/appimagetool --appimage-extract > /dev/null
          mv /opt/squashfs-root /opt/appimagetool.AppDir
          ln -s /opt/appimagetool.AppDir/AppRun /usr/local/bin/appimagetool

      # Our build container minimal and it doesn't contain any systemd package.
      # systemd is responsible for setting up the machine ID files we use for
      # testing the system ID retrieval code, so copy a dummy one
      - name: Set up a dummy D-Bus machine ID for tests
        run: cat /proc/sys/kernel/random/boot_id | tr -d '-' > /run/machine-id

      - name: Run tests
        uses: actions-rs/cargo@v1
        with:
          command: test
          args: --release -- -Z unstable-options --report-time

      - name: Build with optimized standard library
        uses: actions-rs/cargo@v1
        with:
          command: build
          args: --target ${{ env.CARGO_BUILD_TARGET }} -Z build-std --release

      - name: Generate CLI Debian package
        run: scripts/build_deb.sh --target ${{ env.CARGO_BUILD_TARGET }} -p packsquash_cli -- -Z build-std

      - name: Generate CLI AppImage
        env:
          TARGET_APPIMAGE_ARCH: aarch64
          TARGET_APPIMAGE_APT_ARCH: arm64
        run: VERSION="$(git describe --tags --dirty=-custom)"
          appimage-builder --recipe appimage/recipe.yml --skip-test

      - name: Upload CLI binary
        uses: actions/upload-artifact@v3
        with:
          name: 'PackSquash executable (Linux, AArch64-ARM64, glibc)'
          path: target/${{ env.CARGO_BUILD_TARGET }}/release/packsquash

      - name: Upload CLI Debian package
        uses: actions/upload-artifact@v3
        with:
          name: 'PackSquash CLI Debian package (arm64)'
          path: target/${{ env.CARGO_BUILD_TARGET }}/debian/packsquash_*.deb

      - name: Upload CLI AppImage
        uses: actions/upload-artifact@v3
        with:
          name: 'PackSquash CLI AppImage (arm64)'
          path: PackSquash-*-aarch64.AppImage

      - name: Upload CLI AppImage update diff
        uses: actions/upload-artifact@v3
        with:
          name: 'PackSquash CLI AppImage zsync (arm64)'
          path: PackSquash-*-aarch64.AppImage.zsync

  docker:

    runs-on: ubuntu-latest

    env:
      # Defaults to docker.io (Docker Hub)
      REGISTRY: ghcr.io
      # github.repository as <account>/<repo>
      IMAGE_NAME: ${{ github.repository }}

    needs: [ linux-x64-gnu, linux-aarch64-gnu ]

    steps:
      - name: Checkout source
        uses: actions/checkout@v3

      - name: Generate Docker image metadata
        id: meta
        uses: docker/metadata-action@v4
        with:
          images: ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}
          # Tag the image as "edge" for every commit on master.
          # Maintain the "latest", full and major and minor semver tags for each semver tag push
          tags: |
            type=edge,branch=master
            type=semver,pattern={{version}}
            type=semver,pattern={{major}}.{{minor}}
          labels: |
            org.opencontainers.image.description=Docker image for PackSquash, the Minecraft resource and data pack optimizer.

      - name: Download PackSquash x64 AppImage
        uses: actions/download-artifact@v3
        with:
          name: 'PackSquash CLI AppImage (x64)'

      # Docker uses different architecture names
      - name: Rename PackSquash x64 AppImage
        run: mv PackSquash-*-x86_64.AppImage PackSquash-*-amd64.AppImage

      - name: Download PackSquash ARM64 AppImage
        uses: actions/download-artifact@v3
        with:
          name: 'PackSquash CLI AppImage (arm64)'

      - name: Rename PackSquash ARM64 AppImage
        run: mv PackSquash-*-aarch64.AppImage PackSquash-*-arm64.AppImage

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v2

      - name: Check workflow package write permission
        id: check_write_permission
        uses: scherermichael-oss/action-has-permission@1.0.6
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

      # The GitHub token needs the package:write permission for the push to work.
      # This permission is not given to PRs from forked repositories.
      # See: https://docs.github.com/en/actions/security-guides/automatic-token-authentication#permissions-for-the-github_token
      - name: Login to ${{ env.REGISTRY }}
        uses: docker/login-action@v2
        if: steps.check_write_permission.outputs.has-permission
        with:
          registry: ${{ env.REGISTRY }}
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: Build and push Docker image
        uses: docker/build-push-action@v3
        with:
          context: .
          platforms: linux/amd64,linux/arm64
          push: ${{ steps.check_write_permission.outputs.has-permission == '1' }}
          tags: ${{ steps.meta.outputs.tags }}
          labels: ${{ steps.meta.outputs.labels }}

  benchmark:

    runs-on: ubuntu-latest

    container: debian:bullseye-slim

    # Benchmark failure is not critical enough to fail the whole workflow.
    # We will keep an eye on them anyway, though
    continue-on-error: true

    # Make sure that benchmarks stay quick, and handle them being stuck promptly
    timeout-minutes: 30

    # Only benchmark code that passes all the checks
    needs: [ static-analysis, linux-x64-gnu, windows-x64-gnu, macos-x64-darwin, linux-aarch64-gnu ]

    env:
      DEBIAN_FRONTEND: noninteractive

    # Ignore runs that don't have the secret needed to decrypt packs (this happens for PRs outside
    # the repository). First-time would-be contributors need to have their workflows approved
    # anyway, but at best it might be confusing to see commits of PRs mixed with the mainline.
    # Workflows triggered by PRs don't have access to secrets either. We also ignore temporary
    # Renovate branches to reduce noise
    if: success() && github.event_name != 'pull_request' && !startsWith(github.ref_name, 'renovate/')

    steps:
      - name: Install development packages and benchmark script packages
        run: |
          apt-get update
          # curl is required by rustup
          apt-get install -yq build-essential git curl \
                              python3-venv gpg

      - name: Checkout source
        uses: actions/checkout@v3

      - name: Install Rust toolchain
        uses: actions-rs/toolchain@v1
        with:
          profile: minimal

      - name: Cache Rust artifacts
        uses: Swatinem/rust-cache@v1

      - name: Download test packs dataset
        run: scripts/test-packs/download.sh

      - name: Decrypt private test packs in dataset
        env:
          PRIVATE_TEST_PACKS_PASSWORD: ${{ secrets.PRIVATE_TEST_PACKS_PASSWORD }}
        run: scripts/test-packs/decrypt.sh

      # GitHub-hosted runners restrict access to the perf_event_open syscall for some event types we
      # are interested in, so we can't run benchmarks that measure the troublesome performance counters.
      # See: https://github.com/actions/virtual-environments/issues/4974
      - name: Run quick benchmarks
        run: cargo bench -- --output-format=bencher 'wall_time' | tee /run/bench_results.txt

      - name: Publish quick benchmarks results
        uses: benchmark-action/github-action-benchmark@v1
        with:
          name: 'PackSquash library quick benchmarks'
          tool: cargo
          output-file-path: /run/bench_results.txt
          benchmark-data-dir-path: dev/benches
          github-token: ${{ secrets.GITHUB_TOKEN }}
          auto-push: true
          comment-on-alert: true
          alert-threshold: 150%
          fail-on-alert: false
          max-items-in-chart: 50
